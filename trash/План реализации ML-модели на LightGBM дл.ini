План реализации ML-модели на LightGBM для криптосигналов
Шаг 1: Подготовка данных

Собрать исторические сигналы с таблицы (все колонки, включая результаты take_hit/stop_hit).

Выбрать признаки (features):

LTF (30m): ATR, ADX, EMA, MACD, TRIX, Stoch, RSI, CDV, объёмы.

HTF (2h / 4h): ATR, ADX, EMA, MACD, TRIX, Stoch, RSI, CDV, объёмы.

Дивергенции и структурные индикаторы: MACD, RSI, candle_pattern, structural_passed и др.

Глобальный тренд, signal_ltf/htf.

Выбрать целевые переменные (targets):

signal_strength (0–100%) — регрессия

scenario_type (0=агрессивный, 1=умеренный, 2=консервативный) — классификация

short_term_move (размах цены через N часов) — регрессия

Обработать данные:

Заполнить пропуски (например, median/mean)

Нормализация/стандартизация числовых признаков

Кодирование категориальных признаков (One-Hot или Label Encoding)

Шаг 2: Разделение данных

Train / Validation / Test: 70% / 15% / 15%

Можно сортировать по времени, чтобы не было утечки будущего в прошлое.

Шаг 3: Настройка LightGBM

Модель для регрессии силы сигнала и прогноза движения:

objective='regression', metric='rmse'

Модель для классификации сценария:

objective='multiclass', num_class=3, metric='multi_logloss'

Использовать параметры:

num_leaves, max_depth, learning_rate, n_estimators — подбирать через GridSearchCV или RandomSearch

Шаг 4: Обучение модели

Обучаем регрессию и классификацию на соответствующих целевых переменных.

Проверяем метрики: RMSE / MAE для регрессии, Accuracy / F1 для классификации.

Шаг 5: Инференс на новых сигналах

Модель получает свежие признаки: ATR, EMA, объём, дивергенции и др.

Выдаёт:

Сила сигнала (%)

Сценарий (агрессивный / умеренный / консервативный)

Прогноз краткосрочного движения

Post-processing:

Вычисляем цели take1–take5 через ATR и историческую волатильность

Рассчитываем уровень отмены (break level) через EMA и минимум/максимум последних свечей

Шаг 6: Обновление и дообучение

Регулярно добавлять новые сигналы и результаты (hit/miss)

Переобучать модель раз в неделю/месяц для адаптации к рынку

✅ Итог: LightGBM позволит быстро построить рабочую модель с регрессией силы сигнала, классификацией сценария и прогнозом движения, а post-processing выдаст цели, стоп и уровень отмены.






----------------------------------------------------------


План (6 шагов — компактно)

Определить целевую метрику и label.

Рекомендуемый старт: бинарный label target (в вашей БД — =1 если хотя бы один тейк был). Альтернатива: take1_hit для короткого горизонта. (потом можно сделать multi-target).

Решите порог принятия ML (ML_OVERRIDE_THRESHOLD, например 0.75) и режим работы: off | audit | override.

Экспорт обучающего датасета из БД.

Собирать строки, где filters_results (в таблице) уже сохранены (вы вызываете await db_stats.add_filter_result(filters_results) в check_signal). Это означает, что у вас есть фичи в БД — можно вытаскивать напрямую. 

main

Feature selection & engineering.

Использовать числовые фичи: atr_ltf_value, atr_htf_value, adx_ltf_value, adx_htf_value, cdv_ltf_value, cdv_htf_value, cdv_ltf_volume, cdv_htf_volume, volume_value, volume_delta, volume_mean, rsi_ltf, rsi_htf, trix_ltf, trix_htf, macd_current_diff, macd_htf_diff, ema_diff_ltf, ema_diff_htf, candle_pattern_score, structural_score, potential_value, final_scores, scores_config и т. д. (всё из вашей таблицы/строки).

Добавить производные: z-score, rolling mean, time features, symbol-encoding (если нужно).

Train / CV /评估.

Делать time-based split (чтобы избежать утечки). Использовать TimeSeriesSplit или holdout по дате.

Метрики: precision/recall/F1, ROC-AUC; для трейдинга важна precision при режиме override (чтобы не много false positives).

Если классы несбалансированы — scale_pos_weight или is_unbalance в LightGBM / SMOTE / взвешивание.

Сохранение модели и версионирование.

Сохранять модель (joblib.dump) и файл с порядком фич (feature list). Версионировать модель (v1, v2...).

Интеграция в бота (runtime).

Загружать модель при старте (main()/on_startup()), держать в глобальной переменной.

В check_signal(...) (место: функция async def check_signal(...) — см. файл) после подсчёта filters_results и перед await db_stats.add_filter_result(filters_results) вызывать ML-прогноз и добавлять ml_prob, ml_model_version, ml_changed_signal_passed. Если ML_MODE == 'override' и ml_prob >= threshold — пометить is_valid=True и продолжить (помечая, что ML изменил решение). 
